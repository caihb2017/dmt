总结：过了一遍C++网课，了解了C++当中一些基本概念：命名空间、函数指针等。C++作为面向对象语言的一些基本概念和语法：多态实现，虚函数的使用；函数模板的使用；运算符的重载；异常的概念，异常的抛出和捕获方法；标准I/O流、文件I/O流；STL重点看了vector ,array等几个容器和它们的成员函数





##### 面向对象的原理：

+ 对象之间能够交互通信，对象能够**发出消息，接受消息和处理操作**（处理信息，执行信息是由接受的对象做的，与发出信息的对象无关）
+ 面向对象的编程，程序员应该以对象作为编程的单位，直接操作对象而不是对象里面的成员
+ 面向对象的编程，程序可以看作对象的集合 ，这些对象间相互通信，告诉彼此**要做什么**（怎么做是对象本身需要考虑的）
+ **能够接受相同消息的对象属于一个类**



​		对象的接口：

+ 外界只能通过接口访问对象，接口决定了能够接受什么样的信息，而对象能接受什么信息决定了对象属于什么类

+ 修改对象，但接口应该保持不变

+ 接口起到了**封装和保护**的作用，让对象当中的一些成员被保护起来，不能修改；同时也隐藏了对象内部的成员，使用对象时，程序员不需要知道对象内部的情况

+ 接口让对象可以**移植**，只需要保证接口相同，就可以更换不同的对象，就能够将对象移植到其他地方。（程序中各部分的耦合是松散的）

  
  
  对象中公开的部分，即外界可操纵的部分
  
  

头文件的使用：

应用在模块化编程当中，使用头文件管理结构和函数的声明，避免声明的代码在多个cpp.文件中重复，便于维护 



##### 命名空间：

​		命名空间是避免命名冲突的一种手段：**同一命名空间内的成员不能重名**（重载的情况除外），重名的函数和变量由于在不同的命名空间，而得以区分。（存在同名变量时，优先访问局部的变量，然后才访问全局的变量）

​		定义命名空间后，**其中成员（例如函数、变量、类等）的作用域仅在命名空间内**，因此只有展开命名空间，它们才能被访问。（使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染）。不通过命名空间访问，这些变量、结构、函数是不可见的。

​		命名空间定义可以声明和定义结构、函数。为将接口（声明）和实现（定义）分开，**命名空间最好只有声明**

命名空间的使用：

+ 命名空间名+ ：：+变量/函数名；  特别的，定义在全局域中的函数或者变量，如果要在局部使用，可以：：+函数/变量名 std::cin
+ 全部展开 using namespace N1；
+ 部分展开  using namespace N1::S1（**命名空间可以嵌套定义**，S1嵌套在N1中)

+ 命名空间必须在全局域中声明。

+ C++标准库的命名空间std

当展开std后，C++标准库中的类才可以被访问，函数才可以被调用







#### 多态：

##### 多态的定义及实现

1.重写/覆盖 的要求
重写/覆盖： 子类中有一个跟父类完全相同的虚函数，子类的虚函数重写了基类的虚函数
即：子类父类都有这个虚函数 + 子类的虚函数与父类虚函数的 函数名/参数/返回值 都相同 -> 重写/覆盖（注意：参数只看类型是否相同，不看缺省值）

2.多态两个要求：
 1、被调用的函数必须是虚函数，子类对父类的虚函数进行重写 （重写：三同（函数名/参数/返回值）+虚函数）
 2、父类指针或者引用去调用虚函数

多态的实现举例：

```
class Person {
public:
	Person(const char* name)
		:_name(name)
	{}
virtual void BuyTicket()
{ 
    cout << _name << "Person：买票-全价 100￥" << endl;
}

protected:
	string _name;
	//int _id;
};

class Student : public Person {
public:
	Student(const char* name)
		:Person(name)
	{}

	// 虚函数 + 函数名/参数/返回值 -》 重写/覆盖
	virtual void BuyTicket() 
	{ 
	    cout << _name << " Student：买票-半价 50 ￥" << endl; 
	}

};

void Pay(Person& ptr)
{
	ptr.BuyTicket();
}

int main()
{
        string name;
		cin >> name;
		Student s(name.c_str());
		Pay(s);
}


```



##### 虚函数

​		在实现c++多态时会用到虚函数。虚函数使用的其核心目的是**通过基类访问派生类定义的函数**。所谓虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性，可在子类虚函数都加上virtual关键字。一般格式：

```
class base
{
public:
 base();
 virtual void test(); //定义的一个虚函数
private:
 char *basePStr;
};
```

​	    普通函数的继承是实现继承，即子类能够继承父类的函数实现，而虚函数的继承只能继承函数原型。这是由于

虚函数的重写：

+ 虚函数重写/覆盖条件：虚函数(只有成员函数才能加virtual)+三同（函数名、参数、返回值）

+ 子类虚函数不加virtual，依旧构成重写。（先继承下虚函数，再重写（实现））

+ 析构函数的重写（基类与派生类析构函数的名字不同）
  如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。 （建议定义成虚构函数）

  



override和final

+ final：修饰虚函数，表示该虚函数不能再被重写 
+  override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错

![image-20240726100701226](C:\Users\17620\AppData\Roaming\Typora\typora-user-images\image-20240726100701226.png)









#### 异常：

异常是面向对象语言处理错误的一种方式。当一个函数出现自己无法处理的错误时，可以抛出异常。

三个关键字：

throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。
catch：用于捕捉异常。catch(...)可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。
try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。
        注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。



优点：		

​		异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。
在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。
部分函数更好处理，比如没有返回值的函数或者返回值为自身的T& operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。



##### 异常的抛出和捕获：

+ 异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。

+ 被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。

+ 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。

+ catch(...)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。

​		实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。

##### 		异常的匹配规则：

1. 首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。

 2. 如果没有匹配的catch块，则退出但钱函数栈，在调用函数的栈中查找匹配的catch。
 3. 如果到达main函数的栈，都没有匹配的catch，就会终止程序。上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(...)来捕获任意类型的异常，防止程序终止。找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行





#### 流

C++中把数据之间的传输操作称为流，流既可以表示数据从内存传送到某个载体或设备中，即输出流，也可以表示数据从某个载体或设备传送到内存缓冲区变量中，即输入流。


C++流涉及以下概念：

标准I/O流：内存与标准输入输出设备之间信息的传递；
文件I/O流：内存与外部文件之间信息的传递；
字符串I/O流：内存变量与表示字符串流的字符数组之间信息的传递



##### 标准I/O流：

C++标准库提供了4个全局流对象cin、cout、cerr、clog，使用cout进行标准输出，即数据从内存流向控制台(显示器)。使用cin进行标准输入即数据通过键盘输入到程序中，同时C++标准库还提供了cerr用来进行标准错误的输出，以及clog进行日志的输出，从上图可以看出，cout、cerr、clog是ostream类的三个不同的对象，因此这三个对象现在基本没有区别，只是应用场景不同。

在使用时候必须要包含头文件并引入std标准命名空间。

注意：
(1). cin为缓冲流。键盘输入的数据保存在缓冲区中，当要提取时，是从缓冲区中拿。如果一次输入过多，会留在那儿慢慢用，如果输入错了，必须在回车之前修改，如果回车键按下就无法挽回了。只有把输入缓冲区中的数据取完后，才要求输入新的数据。

(2). 输入的数据类型必须与要提取的数据类型一致，否则出错。出错只是在流的状态字state中对应位置，程序继续。

(3). 空格和回车都可以作为数据之间的分格符，所以多个数据可以在一行输入，也可以分行输入。但如果是字符型和字符串，则空格（ASCII码为32）无法用cin输入，字符串中也不能有空格。回车符也无法读入



##### 文件I/O流：

ofstream
输出文件流，用于创建文件并向文件写入信息
ifstream
输入文件流，用于从文件读取信息
fstream
文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息

文件常见的打开方式 :
(1). in 以读的方式打开文件
(2). out 以写的方式打开文件
(3). binary 以二进制方式对文件进行操作
(4). ate 输出位置从文件的末尾开始
(5). app 以追加的方式对文件进行写入
(6). trunc 先将文件内容清空再打开

常用成员函数
(1). put 插入一个字符到文件
(2). write 插入一段字符到文件
(3). get 从文件提取字符
(4). read 从文件提取多个字符
(5). tellg 获取当前字符在文件当中的位置
(6). seekg 设置对文件进行操作的位置
(7). >>运算符重载 将数据形象地以“流”的形式进行输入(用于文本文件)
(8). <<运算符重载 将数据形象地以“流”的形式进行输出(用于文本文件)



#### STL（未完待续）：

STL（ standard template library），标准模板库，是C++标准库的组成部分。STL包含有大量的模板类和模板函数，C++ STL 一共提供了六大组件，包括 容器，算法，迭代器，仿函数，配接器和配置器 ，彼此可以组合套用。这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等

1. ##### 容器：

###### **向量vector**:

vector在顺序存储，随机存取等方面具有和数组相似的特征，可以视为一种动态储存的模板类型的数组。

​		定义和初始化

vector<typename> name;
上面这个定义其实相当于是一维数组name[size]，只不过其size可以根据需要进行变化，这就是“变长数组”的名字的由来。这里的typename可以是任何基本类型，例如int、double、char、结构体等，也可以是STL标准容器，例如set、queue、vector


vector<int> v{1,2,3,4,5}; 直接使用花括号赋值
vector<int> v(5);              初始化5个值为0的元素
vector<int> v(5, 4);          初始化5个值为4的元素

常用函数实例：

| 函数原型    | 功能                                       |
| ----------- | ------------------------------------------ |
| push_back() | 在vector尾添加元素                         |
| pop_back()  | 删除vector尾元素                           |
| size()      | 返回vector长度                             |
| clear()     | 清空vector                                 |
| insert()    | 在指定位置插入元素                         |
| erase()     | 删除指定区间的元素                         |
| begin()     | 返回指向容器第一个元素的迭代器             |
| end()       | 返回指向容器最后一个元素后一个位置的迭代器 |



###### array:

​        和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素

array容器的建立：
array容器的建立一定要给出存储的数据类型和容器的大小

​       array<double, 10> values;

由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。

​      array<double, 10> values{};                元素初始化为0

​      array<double,10>values{0,0.1,0.1}    初始化前三个元素



array容器成员函数汇总

begin()

返回指向容器中第一个元素的随机访问迭代器。

end()

返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。

rbegin()

返回指向最后一个元素的随机访问迭代器。

rend()

返回指向第一个元素之前一个位置的随机访问迭代器。

cbegin()

和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。

cend()

和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。

crbegin()

和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。

crend()

和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。

size()

返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。注意：这里的butongyv其他容器的size(),不是获取有多少元素，就相当于vector的capacity.

max_size()

返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。


array和vector对比：
vector	

本质上是静态空间，只是vector内部机制会自动进行内存的重新配置，移动数据，释放旧空间。

随着元素的加入，内部空间会自动拓展空间来容纳新元素。空间自动拓展。模板参数2个，但是建立容器时只需要一个参数	

array	

内存空间的大小固定，如果所需内存超出固定内存，需要重新配置，移动数据，释放旧空间。空间由程序员手动拓展。模板参数2个，建立容器也要两个

